#include "rclcpp/rclcpp.hpp"
#include "qbo_arduqbo/controllers/dynamixel_controller.hpp"

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);

    rclcpp::NodeOptions options;
    options.allow_undeclared_parameters(true);
    options.automatically_declare_parameters_from_overrides(true);

    auto node = rclcpp::Node::make_shared("qbo_dynamixel", options);
    RCLCPP_INFO(node->get_logger(), "ğŸ¬ Starting qbo_dynamixel node");

    try
    {

        std::string usb_port = "";
        int baud_rate = -1;
        double protocol_version = -1.0;

        // RÃ©cupÃ©ration des valeurs
        node->get_parameter("dynamixel.usb_port", usb_port);
        node->get_parameter("dynamixel.baud_rate", baud_rate);
        node->get_parameter("dynamixel.protocol_version", protocol_version);

        // VÃ©rifications simples
        if (usb_port.empty()) {
            RCLCPP_FATAL(node->get_logger(), "âŒ USB port is not defined (key: dynamixel.port)");
            return 1;
        }
        if (baud_rate <= 0) {
            RCLCPP_FATAL(node->get_logger(), "âŒ Invalid baud rate: %d", baud_rate);
            return 1;
        }
        if (protocol_version != 1.0 && protocol_version != 2.0) {
            RCLCPP_FATAL(node->get_logger(), "âŒ Invalid protocol version: %.1f (expected: 1.0 or 2.0)", protocol_version);
            return 1;
        }

        std::vector<std::string> motor_keys;
        node->get_parameter("dynamixel.motor_keys", motor_keys);

        // âœ… VÃ©rification prÃ©sence de config
        if (motor_keys.empty()) {
            RCLCPP_FATAL(node->get_logger(),
                "âŒ No motor is defined. Check the YAML file (key: dynamixel.motor_keys).");
            return 1;
        }

        RCLCPP_INFO(node->get_logger(), "âœ… Initial configuration validated, launching controller...");
        auto controller = std::make_shared<DynamixelController>(node);
        RCLCPP_INFO(node->get_logger(), "âœ… DynamixelController ready.");
        rclcpp::spin(node);
    }
    catch (const std::exception &e)
    {
        RCLCPP_FATAL(node->get_logger(), "ğŸ›‘ Fatal exception: %s", e.what());
        return 1;
    }

    rclcpp::shutdown();
    return 0;
}
